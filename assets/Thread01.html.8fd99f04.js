import{_ as n,V as a,W as s,a0 as e}from"./framework.3bd681ae.js";const p={},t=e(`<h1 id="线程的创建、中断及通信" tabindex="-1"><a class="header-anchor" href="#线程的创建、中断及通信" aria-hidden="true">#</a> 线程的创建、中断及通信</h1><h2 id="线程的三种创建方式" tabindex="-1"><a class="header-anchor" href="#线程的三种创建方式" aria-hidden="true">#</a> 线程的三种创建方式</h2><h3 id="继承thread" tabindex="-1"><a class="header-anchor" href="#继承thread" aria-hidden="true">#</a> 继承Thread</h3><p>我们在代码中想要简单的启动一个线程，最熟悉的方式就是继承 Thread ，这个类是JDK提供的一个线程类，这个类实现了 Runnable 接口，我们可以来看看 Thread 比较常用的几个方法</p><p>首先是其构造方法</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47c55c32b4184a07ad20d24f15167c1a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>构造方法我们只需要重点关注前面两个就可以了，一个是无参构造，一个是传入 Runnable 的实现类</p><p>其他比较常用的方法：</p><blockquote><p>public synchronized void start() ： 启动线程</p><p>public void run()：线程具体执行的方法，需要在继承的类中重写</p><p>public static native void sleep(long millis) ：线程休眠，需要传入休眠的时间，该方法会暂停线程执行直到线程休眠时间结束</p><p>public static void sleep(long millis, int nanos)：跟上一个方法一样，只不过多传了个时间机制</p><p>public void interrupt()：给线程打上一个中断标识</p><p>public boolean isInterrupted()：判断线程是否被打上中断标识</p><p>public final synchronized void setName(String name)：给线程设置一个名称</p><p>public final void join()：让主线程等待子线程执行结束</p><p>public static native void yield()：表示当前线程愿意让出CPU使用权</p></blockquote><p>方法具体的使用我这里就不一一讲解了，我们直接来看看代码的实现细节</p><p>示例代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 自定义类继承 Thread </span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread01</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread01</span> thread01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 启动线程</span>
    thread01<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="实现runnable接口" tabindex="-1"><a class="header-anchor" href="#实现runnable接口" aria-hidden="true">#</a> 实现Runnable接口</h3><p>Runnable 内部提供了一个 run 抽象方法，上面我也说过 Thread 实现了 Runnable 接口</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba9c5e3290d14a94a4217564f6dee130~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>因为 Runnable 没有给我们提供启动线程的方法，因此我们需要借助 Thread 类来启动</p><p>代码示例如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 自定义类实现 Runnable 接口</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread02</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread02</span> thread02 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 借助 Thread 类来启动</span>
    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>thread02<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 启动线程</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="实现callable接口" tabindex="-1"><a class="header-anchor" href="#实现callable接口" aria-hidden="true">#</a> 实现Callable接口</h3><p>上面的两种方式创建线程有一个缺点，但是无法获取到线程执行的结果，我们可以通过实现 Callable 接口从而获得线程执行的结果</p><p>同样 Callable 也只提供了一个方法，同时接口接收一个泛型作为返回的结果参数</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/857f914041504093aa24280323cbfd00~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>Callable 也没有提供启动线程的方法，因此我们也需要借助 Thread 类来启动</p><p>但是我们可以看到 Thread 除了 Runnable 传参的构造方法之外，并没有提供 Callable 传参的构造方法，因此我们无法直接通过 Thread 来启动，需要一个媒介，这个媒介就是 FutureTask，其实细心点我们可以发现，Callable 和 FutureTask 都是 JUC 并发包下的</p><p>FutureTask 继承了 Runnable 接口，因此 FutureTask 本身就是 Runnable 的一个实现</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f868e07696349cc8109230901994996~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>FutureTask 也提供了两个构造方法，一个是 Callable 传参，一个是 Runnable传参</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5c6ca3b3c38488aac533b3299c2dbb6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>因此我们可以将 Callable 的实现包装成一个 FutureTask，然后再通过 Thread 来启动</p><p>示例代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 自定义 Callable 实现</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread03</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;这是一个线程执行的结果.....&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread03</span> thread03 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 包装成 FutureTask</span>
    <span class="token class-name">FutureTask</span> futureTask<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span>thread03<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 借助 Thread 类启动</span>
    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 获取执行的结果</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="线程的生命周期" tabindex="-1"><a class="header-anchor" href="#线程的生命周期" aria-hidden="true">#</a> 线程的生命周期</h2><p>就跟Spring的Bean一样，线程也有生命周期</p><p>Java的线程生命周期一共有六种状态：</p><p><strong>NEW(初始化状态)</strong></p><p><strong>RUNNABLE(可运行/运行状态)</strong></p><p><strong>BLOCKED(阻塞状态)</strong></p><p><strong>WAITING(无时限等待)</strong></p><p><strong>TIMED_WAITING(有时限等待)</strong></p><p><strong>TERMINATED(终止状态)</strong></p><p>其中 BLOCKED、WAITING、TIMED_WAITING 这三种状态我们可以归结为一种状态，即休眠状态，因为这三种状态只要是其中的一种，那么这个线程就会永远的没有CPU的使用权</p><p>我们再来看看线程状态之间是如何进行转换的</p><p>1、从 NEW 到 RUNNABLE 状态</p><p>Java 刚创建出来的 Thread 对象就是NEW状态，此时JVM为其分配内存，并初始化其成员变量的值，线程并不会执行线程执行体</p><p>当调用 start() 方法，就会从 NEW 转换到 RUNNABLE 状态</p><p>2、RUNNABLE 到 BLOCKED 状态</p><p>当线程调用 synchronized 修饰的方法或代码块的时候，其他的线程就只能等待，而等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态</p><p>当等待的线程获得 synchronized 隐式锁时，又会从 BLOCKED 转换到 RUNNABLE 状态</p><p>3、RUNNABLE 到 WAITING 状态</p><p>有三种场景会触发这两个状态的转换</p><p>第一种场景，获取synchronized 隐式锁的线程，调用无参数的 Object.wait() 方法</p><p>第二种场景，调用无参数的 Thread.join() 方法，如果有个线程 ThreadA ，当调用 ThreadA.join() 的时候，执行这条语句的线程就会等待 ThreadA 执行完，而等待的过程中，状态就会从 RUNNABLE 转换到 WAITING，当 ThreadA 执行完的之后，等待的线程就会从 WAITING 转换到 RUNNABLE</p><p>第三种场景，调用 LockSupport.park() 方法，当线程调用这个方法的时候，状态就会从 RUNNABLE 状态转换到 WAITING ，调用 LockSupport.unpark() 可唤醒目标线程，目标线程状态又会从 WAITING 状态到 RUNNABLE 状态</p><p>4、RUNNABLE 到 TIMED_WAITING 状态</p><p>这种状态的转换有五种场景</p><p>第一种场景，调用带超时参数的 Thread.sleep(long millis) 方法</p><p>第二种场景，获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法</p><p>第三种场景，调用带超时参数的 Thread.join(long millis) 方法</p><p>第四种场景，调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法</p><p>第五种场景，调用带超时参数的 LockSupport.parkUntil(long deadline) 方法</p><p>TIMED_WAITING 和 WAITING 状态的区别就在于多了个超时参数</p><p>5、 RUNNABLE 和 WAITING 状态的区别</p><p>线程执行完 run() 方法后，会自动转换到 TERMINATED 状态，当然如果执行 run() 方法的 时候异常抛出，也会导致线程终止</p><h2 id="线程的中断策略" tabindex="-1"><a class="header-anchor" href="#线程的中断策略" aria-hidden="true">#</a> 线程的中断策略</h2><p>我们有时候可能会终止线程的运行，比如某些中间件，在正常关闭的时候可能需要终止某些正在运行的线程</p><p>Thread 提供了一个 stop() 方法，这个方法会直接终止线程，不给任何喘息的机会</p><p>但是这么暴力的终止线程也会存在一个问题，就是如果线程正在执行某些任务，恰好这个线程持有 ReentrantLock 锁 ，一旦我们通过暴力的形式终止线程，线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁，那么这个锁将永远得不到释放，因此 JDK 官方是不建议使用 stop 方法来终止线程，另外这个方法也被标注为过时了</p><p>Thread 给我们提供了一个 interrupt() 方法， 这个方法相对来说就优雅的多了</p><p>当调用这个方法的之后，并不会终止线程，而是会给这个线程打上一个终止标记，标记这是个终止的线程，后续处理的时候，我们只需要调用 isInterrupted() 方法判断该线程是否是终止线程，如果是的话我们再做终止处理，同时我们也可以无视这个终止标记</p><p>除了调用 isInterrupted() 主动检测外，另外一种就是通过异常来检测</p><p>我们如果调用 wait()、join()、sleep() 方法都会抛出一个 InterruptedException 异常，这个异常的触发条件就是：其他线程调用了该线程的 interrupt() 方法</p><h2 id="线程之间的通信" tabindex="-1"><a class="header-anchor" href="#线程之间的通信" aria-hidden="true">#</a> 线程之间的通信</h2><p>线程与线程之间不完全是互相独立的，也需要某种通信机制来达到互相协助的目的</p><p>Object 给我们提供了 wait()、notifyAll()、notify() 三个方法，线程调用 wait() 方法会进入到等待，调用 notifyAll()、notify() 会唤醒等待的线程</p><p>notifyAll()、notify() 区别在于 :</p><p>notify()唤醒正在等待此对象监视器的单个线程。 如果有多个线程在等待，则选择其中一个随机唤醒（由调度器决定），唤醒的线程享有公平竞争资源的权利</p><p>notifyAll()唤醒正在等待此对象监视器的所有线程，唤醒的所有线程公平竞争资源</p><p>我们来通过一个代码示例来具体说明下</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread01</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>

    <span class="token keyword">private</span>  <span class="token class-name">Object</span> lock<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Thread01</span><span class="token punctuation">(</span><span class="token class-name">Object</span> lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>lock <span class="token operator">=</span> lock<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 调用 wait 方法，线程进入等待</span>
                lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;被唤醒...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public static void main(String[] args) throws Exception {
        Object lock = new Object();
        Thread01 thread01 = new Thread01(lock);
        thread01.setName(&quot;线程1&quot;);
        // 启动线程后，线程会被阻塞等待
        thread01.start();
        
        Thread.sleep(3000);
        synchronized (lock){
            // 唤醒正在等待的线程
            lock.notify();
        }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体的细节我在注释里说明了，感兴趣的话，可以自己运行下这个代码</p><p>这种通信机制有缺点因此很少使用，JUC 并发包提供了 LockSupport 类，这个类提供了 part()和unpark()两个方法，分别对应线程的阻塞和唤醒，一般会使用这种方式做线程的通信</p>`,85),c=[t];function l(o,i){return a(),s("div",null,c)}const d=n(p,[["render",l],["__file","Thread01.html.vue"]]);export{d as default};
